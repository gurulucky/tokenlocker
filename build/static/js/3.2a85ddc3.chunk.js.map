{"version":3,"sources":["web3.js"],"names":["provider","serverApi","explorer","deposit","token","amount","date","account","network","a","unlockDate","Date","UTCTimestamp","Math","round","getTime","web3","Web3","contract","eth","Contract","lockerContractAbi","lockerAddress","methods","feesInETH","call","feeInETH","address","BigInt","send","from","value","pow","toString","result","status","withdraw","id","approve","erc20Abi","utils","toBN","approveToken","deployedContract","allowance","getTokenBalance","getData","axios","get","response","lockerDataByWallet","data","checkWalletAddress","walletAddress","isAddress","getLastDeployedContract","lastDeployedAddress","deployContract","abi","swapTokenLockerFactory","createTokenLocker","sendTokenVesting","csvData","_users","_amounts","_lockHours","_sendAmount","decimals","map","each","push","period","length","slice","console","log","sendLockTokenMany","getClaimTokenList","factoryContract","getAllContracts","allContracts","multicall","Multicall","web3Instance","tryAggregate","contractCallContext","index","reference","contractAddress","calls","methodName","methodParameters","returnData","Object","entries","results","key","callsReturnContext","returnValues","hex","claimedAmount","lockTimestamp","lastUpdated","lockHours","name","symbol","claimToken","tokenDetail","currentTimestamp","floor","now","state","reason","passedHours","availableAmount","Number","maxTxLimit","airdrop","toChecksumAddress","airdropAddress"],"mappings":"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","file":"static/js/3.2a85ddc3.chunk.js","sourcesContent":["import Web3 from \"web3\"\r\nimport {\r\n    Multicall\r\n  } from 'ethereum-multicall';\r\n\r\nimport lockerContractAbi from \"./locker_abi.json\"\r\nimport erc20Abi from \"./erc20_abi.json\"\r\nimport liquidityPoolAbi from \"./liquidityPool_abi.json\"\r\nimport axios from 'axios'\r\nimport { maxTxLimit, lockerAddress, swapTokenLockerFactory, airdropAddress } from './constants'\r\n\r\n\r\nconst provider = {\r\n    \"Ethereum\": \"https://mainnet.infura.io/v3/3587df9c45a740f9812d093074c6a505\",\r\n    \"Binance Smart Chain\": \"https://data-seed-prebsc-1-s1.binance.org:8545\",\r\n    \"Avalanche\": \"https://api.avax.network/ext/bc/C/rpc\",\r\n    \"Avalanche_testnet\": \"https://api.avax-test.network/ext/bc/C/rpc\"\r\n};\r\n\r\nconst serverApi = 'http://localhost:5000/api';\r\n// const serverApi = 'https://localhost:5000/api';\r\n// const serverApi = 'https://app.snowprotocol.io/api';\r\n\r\nexport const explorer = {\r\n    \"Ethereum\": \"https://etherscan.io\",\r\n    \"Binance Smart Chain\": \"https://bscscan.com\",\r\n    \"Avalanche\": \"https://snowtrace.io\",\r\n    \"Avalanche_test\": \"https://testnet.snowtrace.io\"\r\n};\r\n\r\nexport const deposit = async (provider, token, amount, date, account, network) => {\r\n    let unlockDate = new Date(date);\r\n    let UTCTimestamp = Math.round(unlockDate.getTime() / 1000)\r\n    let web3 = new Web3(provider);\r\n    let contract = new web3.eth.Contract(lockerContractAbi, lockerAddress[network]);\r\n    let feeInETH = await contract.methods.feesInETH().call();\r\n    let result = await contract.methods[\"lockTokens\"](token.address, account, BigInt(amount), UTCTimestamp).send({from: account, value: network === \"Avalanche\" || network === \"Avalanche_testnet\" ? BigInt(feeInETH * Math.pow(10, 18)).toString() : feeInETH});\r\n    return result.status;\r\n}\r\n\r\nexport const withdraw = async (provider, id, account, network) => {\r\n    let web3 = new Web3(provider);\r\n    let contract = new web3.eth.Contract(lockerContractAbi, lockerAddress[network]);\r\n    let result = await contract.methods[\"withdrawTokens\"](id).send({\r\n        from: account\r\n    });\r\n    return result.status;\r\n}\r\n\r\nexport const approve = async (provider, token, account, network) => {\r\n    let web3 = new Web3(provider);\r\n    let contract = new web3.eth.Contract(erc20Abi, token.address);\r\n    let result = await contract.methods[\"approve\"](lockerAddress[network], web3.utils.toBN(\"115792089237316195423570985008687907853269984665640564039457584007913129639935\")).send({from: account});\r\n    return result.status;\r\n}\r\n\r\nexport const approveToken = async (provider, token, account, deployedContract) => {\r\n    let web3 = new Web3(provider);\r\n    let contract = new web3.eth.Contract(erc20Abi, token);\r\n    let result = await contract.methods[\"approve\"](deployedContract, web3.utils.toBN(\"115792089237316195423570985008687907853269984665640564039457584007913129639935\")).send({from: account});\r\n    return result.status;\r\n}\r\n\r\nexport const allowance = async (token, account, network) => {\r\n    let web3 = new Web3(provider[network]);\r\n    let contract = new web3.eth.Contract(erc20Abi, token.address);\r\n    let result = await contract.methods[\"allowance\"](account, lockerAddress[network]).call();\r\n    return result;\r\n}\r\n\r\nexport const getTokenBalance = async (token, account, network) => {\r\n    let web3 = new Web3(provider[network]);\r\n    let contract = new web3.eth.Contract(erc20Abi, token.address);\r\n    let result = await contract.methods[\"balanceOf\"](account).call();\r\n    return result;\r\n}\r\n\r\nexport const getRawData = async (account, network) => {\r\n    let web3 = new Web3(provider[network]);\r\n    let contract = new web3.eth.Contract(lockerContractAbi, lockerAddress[network]);\r\n    let depositIds = await contract.methods[\"getAllDepositIds\"]().call();\r\n    if (!depositIds.length) return []\r\n    const multicall = new Multicall({ web3Instance: web3, tryAggregate: true });\r\n    let contractCallContext = {\r\n        reference: \"lockedToken\",\r\n        contractAddress: lockerAddress[network],\r\n        abi: lockerContractAbi,\r\n        calls: depositIds.map(each => {\r\n            return { reference: 'lockedTokensCall', methodName: 'lockedToken', methodParameters: [each] }\r\n        })\r\n    }\r\n    let response = await multicall.call(contractCallContext);\r\n    const returnValues = [];\r\n    response.results.lockedToken.callsReturnContext.map(each => {\r\n        const returnValue = {\r\n            id: each.methodParameters[0],\r\n            token: each.returnValues[0],\r\n            owner: each.returnValues[1],\r\n            amount: BigInt(parseInt(each.returnValues[2].hex, 16)).toString(),\r\n            timestamp: parseInt(each.returnValues[3].hex, 16),\r\n            isWithdrawn: each.returnValues[4]\r\n        }\r\n        if (returnValue.owner.toLowerCase() === account.toLowerCase()) returnValues.push(returnValue);\r\n    })\r\n    return returnValues;\r\n\r\n        // let lockedTokenLists = [];\r\n        // for (const [key, value] of Object.entries(response.results)) {\r\n        //     lockedTokenLists.push(value.callsReturnContext[0][\"returnValues\"][0]);\r\n        // }\r\n        // contractCallContext = [];\r\n        // for (let i = 0; i < length; i++) {\r\n        //     contractCallContext.push({\r\n        //         reference: i,\r\n        //         contractAddress: lockerAddress,\r\n        //         abi: lockerContractAbi,\r\n        //         calls: [{ reference: 'lockedTokensCall', methodName: 'getUserTokenInfo', methodParameters: [lockedTokenLists[i], account] }]\r\n        //     })\r\n        // }\r\n        // response = await multicall.call(contractCallContext);\r\n        // let userInfo = [];\r\n        // for (const [key, value] of Object.entries(response.results)) {\r\n        //     if (web3.utils.hexToNumberString(value.callsReturnContext[0].returnValues[2].hex) == '0') continue;\r\n        //     userInfo.push({token: lockedTokenLists[key], deposited: web3.utils.hexToNumberString(value.callsReturnContext[0].returnValues[0].hex), withdrawed: web3.utils.hexToNumberString(value.callsReturnContext[0].returnValues[1].hex), vestLength: web3.utils.hexToNumberString(value.callsReturnContext[0].returnValues[2].hex)})\r\n        // }\r\n        // if (!userInfo.length) return [];\r\n        // contractCallContext = [];\r\n        // for (let i = 0; i < userInfo.length; i++) {\r\n        //     let context = {\r\n        //         reference: i,\r\n        //         contractAddress: lockerAddress,\r\n        //         abi: lockerContractAbi,\r\n        //         calls: []\r\n        //     }\r\n        //     for (let j = 0; j < userInfo[i][\"vestLength\"]; j++) {\r\n        //         context.calls.push({ reference: 'getUserVestingAtIndexCall', methodName: 'getUserVestingAtIndex', methodParameters: [userInfo[i].token, account, j] });\r\n        //     }\r\n        //     contractCallContext.push(context)\r\n        // }\r\n        // response = await multicall.call(contractCallContext);\r\n        // for (const [key, value] of Object.entries(response.results)) {\r\n        //     userInfo[key][\"vesting\"] = value.callsReturnContext.map(each => {\r\n        //         return each.returnValues.map(data => {\r\n        //             return web3.utils.hexToNumberString(data.hex)\r\n        //         })\r\n        //     })\r\n        // }\r\n        // contractCallContext = [];\r\n        // for (let i = 0; i < userInfo.length; i++) {\r\n        //     let context = {\r\n        //         reference: i,\r\n        //         contractAddress: userInfo[i][\"token\"],\r\n        //         abi: erc20Abi,\r\n        //         calls: [{ reference: 'decimalsCall', methodName: 'decimals' }, { reference: 'symbolCall', methodName: 'symbol'}]\r\n        //     }\r\n        //     contractCallContext.push(context);\r\n        // }\r\n        // response = await multicall.call(contractCallContext);\r\n        // for (const [key, value] of Object.entries(response.results)) {\r\n        //     userInfo[key][\"decimals\"] = value.callsReturnContext[0][\"returnValues\"][0];\r\n        //     userInfo[key][\"symbol\"] = value.callsReturnContext[1][\"returnValues\"][0];\r\n        // }\r\n        // let currentTime = Math.round(Date.now() / 1000);\r\n        // // console.log(userInfo)\r\n        // userInfo = userInfo.map(each => {\r\n        //     console.log(each);\r\n        //     let withdrawable = web3.utils.toBN(0);\r\n        //     each.vesting.map((eachVest) => {\r\n        //         if (Number(eachVest[0]) < currentTime) withdrawable = withdrawable.add(web3.utils.toBN(eachVest[1]));\r\n        //     })\r\n        //     withdrawable = withdrawable.sub(web3.utils.toBN(each.withdrawed));\r\n        //     each.withdrawable = withdrawable.toString();\r\n        //     return each;\r\n        // })\r\n    }\r\n    \r\nexport const getData = async (account, network) => {\r\n    const response = await axios.get(`${serverApi}/locker/lockedtokens/${network}/${account}`);\r\n    const lockerDataByWallet = response.data;\r\n    return lockerDataByWallet;\r\n}\r\n\r\nexport const getLockedTokenDetails = async (tokenAddress, account, network) => {\r\n\r\n    // const tokenData = data.find(each => each.address === tokenAddress);\r\n    \r\n    const rawData = await getRawData(account, network);\r\n    let web3 = new Web3(provider[network]);\r\n\r\n    let tokenLocked = BigInt(0);\r\n    rawData.map(each => {\r\n        if (each.token === tokenAddress && !each.isWithdrawn) tokenLocked = tokenLocked + BigInt(each.amount);\r\n    });\r\n    // console.log(rawData)\r\n    const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);\r\n    let symbol = await tokenContract.methods.symbol().call();\r\n    let decimals = await tokenContract.methods.decimals().call();\r\n    let totalSupply = await tokenContract.methods.totalSupply().call();\r\n    let liquidityLocked = BigInt(0);\r\n    let tokenLockHistory = [];\r\n\r\n    const multicall = new Multicall({ web3Instance: web3, tryAggregate: true });\r\n    let contractCallContext = rawData.map((each, index) => {\r\n        return {\r\n            reference: index,\r\n            contractAddress: each.token,\r\n            abi: erc20Abi,\r\n            calls: [{ reference: 'symbolsCall', methodName: 'symbol' }]\r\n        }\r\n    })\r\n    let response = await multicall.call(contractCallContext);\r\n    let symbols = [];\r\n    for (const [key, value] of Object.entries(response.results)) {\r\n        symbols.push(value.callsReturnContext[0].returnValues[0]);\r\n    }\r\n    // console.log(rawData)\r\n    for (let i = 0; i < rawData.length; i++) {\r\n        let each = rawData[i];\r\n        let address = each.token;\r\n        let ownerAddress = each.owner;\r\n        let tokenAmount = each.amount;\r\n        let timestamp = each.timestamp;\r\n        let isWithdrawn = each.isWithdrawn;\r\n        //default token\r\n        if (address.toLowerCase() === tokenAddress.toLowerCase()) tokenLockHistory.push({id: each.id, address: address, owner: ownerAddress, tokenAmount: tokenAmount, timestamp: timestamp, isWithdrawn: isWithdrawn});\r\n        //pool token\r\n        else if (symbols[i] === 'HUL') {\r\n            let poolContract = new web3.eth.Contract(liquidityPoolAbi, each.token);\r\n            let token0 = await poolContract.methods.token0().call();\r\n            let token1 = await poolContract.methods.token1().call();\r\n            if (token0.toLowerCase() === tokenAddress.toLowerCase() || token1.toLowerCase() === tokenAddress.toLowerCase()) {\r\n                let totalSupply = await poolContract.methods.totalSupply().call();\r\n                let baseTokenTotalAmount = await tokenContract.methods.balanceOf(address).call();\r\n                let baseTokenAmount = BigInt(baseTokenTotalAmount) * BigInt(tokenAmount) / BigInt(totalSupply);\r\n                if (!each.isWithdrawn) liquidityLocked = liquidityLocked + baseTokenAmount;\r\n                tokenLockHistory.push({id: each.id, isPool: true, address: address, owner: ownerAddress, tokenAmount: tokenAmount, baseTokenAmount: baseTokenAmount.toString(), timestamp: timestamp, isWithdrawn: isWithdrawn});\r\n            }\r\n        }\r\n    }\r\n    // let tokenSymbol = await tokenContract.methods.symbol().call();\r\n    // let tokenDecimals = await tokenContract.methods.decimals().call();\r\n    // let tokenLocked = await tokenContract.methods.balanceOf(lockerAddress).call();\r\n    // let tokenTotalSupply = await tokenContract.methods.totalSupply().call();\r\n\r\n    let lockerContract = new web3.eth.Contract(lockerContractAbi, lockerAddress[network]);\r\n    let depositEvents = await lockerContract.getPastEvents(\"LogLocking\", {\r\n        fromBlock: 0\r\n    })\r\n    let withdrawEvents = await lockerContract.getPastEvents(\"LogWithdrawal\", {\r\n        fromBlock: 0\r\n    })\r\n\r\n    // let tokenTransferEvents = await tokenContract.getPastEvents(\"Transfer\",{\r\n    //     fromBlock: 0,\r\n    //     toBlock: \"latest\",\r\n    //     filter: {\r\n    //         to: lockerAddress\r\n    //     }\r\n    // })\r\n    // let tokenTransferTransactions = await Promise.all(tokenTransferEvents.map(each => web3.eth.getTransaction(each.transactionHash)))\r\n    // tokenTransferTransactions = tokenTransferTransactions.filter(each => each.input.length === 266);\r\n    \r\n    \r\n    for(let i=0; i<depositEvents.length; i++) {\r\n        let blockDetail = await web3.eth.getBlock(depositEvents[i].blockNumber);\r\n        depositEvents[i].timestamp = blockDetail.timestamp;\r\n    }\r\n    for(let i=0; i<withdrawEvents.length; i++) {\r\n        let blockDetail = await web3.eth.getBlock(withdrawEvents[i].blockNumber);\r\n        withdrawEvents[i].timestamp = blockDetail.timestamp;\r\n    }\r\n    let events = [], j = 0;\r\n    for(let i=0; i<depositEvents.length;i++) {\r\n        if(withdrawEvents[j] && withdrawEvents[j].returnValues.index === depositEvents[i].returnValues.index) {\r\n            events.push({deposit: depositEvents[i], withdraw: withdrawEvents[j]});\r\n            j++;\r\n        } else {\r\n            events.push({deposit: depositEvents[i]});\r\n        }\r\n    }\r\n\r\n    return {\r\n        address: tokenAddress,\r\n        symbol: symbol,\r\n        decimals: decimals,\r\n        totalSupply: totalSupply,\r\n        liquidityLocked: liquidityLocked,\r\n        tokenLocked: tokenLocked,\r\n        history: tokenLockHistory,\r\n        events: events\r\n    }\r\n}\r\n\r\nexport const checkWalletAddress = (walletAddress, network) => {\r\n    let web3 = new Web3(provider[network]);\r\n    return web3.utils.isAddress(walletAddress);\r\n}\r\n\r\nexport const getLastDeployedContract = async (account, network) => {\r\n    const response = await axios.get(`${serverApi}/vesting/lastDeployed/${network}/${account}`);\r\n    const lastDeployedAddress = response.data;\r\n    return lastDeployedAddress;\r\n}\r\n\r\nexport const deployContract = async (provider, account, token, network) => {\r\n    const web3 = new Web3(provider);\r\n    const abi = [{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"createTokenLocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]\r\n    const contract = new web3.eth.Contract(abi, swapTokenLockerFactory[network]);\r\n    let result = contract.methods.createTokenLocker(token).send({\r\n        from: account\r\n    })\r\n    return result;\r\n}\r\n\r\nexport const sendTokenVesting = async (provider, deployedContract, csvData, token, account, network) => {\r\n    let _users = [], _amounts = [], _lockHours = [], _sendAmount = BigInt(0);\r\n    const web3 = new Web3(provider);\r\n    let abi = [{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}];\r\n    let contract = new web3.eth.Contract(abi, token);\r\n    let decimals = await contract.methods.decimals().call();\r\n    csvData.map(each => {\r\n        _users.push(each.address);\r\n        _amounts.push(BigInt(each.amount * Math.pow(10, decimals)).toString());\r\n        switch(each.period[each.period.length - 1]) {\r\n            case 'M':\r\n                _lockHours.push(each.period.slice(0, each.period.length - 1) * 30 * 24);\r\n                break;\r\n            case 'W':\r\n                _lockHours.push(each.period.slice(0, each.period.length - 1) * 7 * 24);\r\n                break;\r\n            case 'D':\r\n                _lockHours.push(each.period.slice(0, each.period.length - 1) * 24);\r\n                break;\r\n            case 'h':\r\n                _lockHours.push(each.period.slice(0, each.period.length - 1));\r\n                \r\n        }\r\n        _sendAmount += BigInt(each.amount * Math.pow(10, decimals));\r\n    })\r\n    _sendAmount = _sendAmount.toString();\r\n    abi = [{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint128[]\",\"name\":\"_amounts\",\"type\":\"uint128[]\"},{\"internalType\":\"uint32[]\",\"name\":\"_lockHours\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256\",\"name\":\"_sendAmount\",\"type\":\"uint256\"}],\"name\":\"sendLockTokenMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesInETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]\r\n    \r\n    contract = new web3.eth.Contract(abi, deployedContract)\r\n    let feesInETH = await contract.methods.feesInETH().call();\r\n    console.log(_users, _amounts, _lockHours, _sendAmount, account)\r\n    let result = await contract.methods.sendLockTokenMany(_users, _amounts, _lockHours, _sendAmount).send({\r\n        from: account,\r\n        value: network === \"Avalanche\" || network === \"Avalanche_testnet\" ? BigInt(feesInETH * Math.pow(10, 18)).toString(): feesInETH\r\n    });\r\n    return result;\r\n}\r\n\r\nexport const getClaimTokenList = async (address, network) => {\r\n    const web3 = new Web3(provider[network]);\r\n    let factoryContract, abi, erc20Abi, allContracts, response, multicall, contractCallContext;\r\n    abi = [{\"inputs\":[],\"name\":\"getAllContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}];\r\n    factoryContract = new web3.eth.Contract(abi, swapTokenLockerFactory[network]);\r\n    allContracts = await factoryContract.methods.getAllContracts().call();\r\n    console.log(allContracts)\r\n    multicall = new Multicall({ web3Instance: web3, tryAggregate: true });\r\n    abi = [{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLockData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}];\r\n    erc20Abi = [{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]\r\n    contractCallContext = allContracts.map((each, index) => {\r\n        return {\r\n            reference: index,\r\n            contractAddress: each,\r\n            abi: abi,\r\n            calls: [\r\n                { reference: 'getLockDataCall', methodName: 'getLockData', methodParameters: [address] },\r\n                { reference: 'getTokenCall', methodName: 'getToken'}\r\n            ]\r\n        }\r\n    })\r\n    response = await multicall.call(contractCallContext);\r\n    let returnData = [];\r\n    contractCallContext = [];\r\n    for (const [key, value] of Object.entries(response.results)) {\r\n        let amount = BigInt(value.callsReturnContext[0].returnValues[0].hex).toString();\r\n        let claimedAmount = BigInt(value.callsReturnContext[0].returnValues[1].hex).toString();\r\n        let lockTimestamp = BigInt(value.callsReturnContext[0].returnValues[2].hex).toString();\r\n        let lastUpdated = BigInt(value.callsReturnContext[0].returnValues[3].hex).toString();\r\n        let lockHours = value.callsReturnContext[0].returnValues[4];\r\n        let contract = allContracts[key];\r\n        let token = value.callsReturnContext[1].returnValues[0];\r\n        if (amount !== '0') {\r\n            contractCallContext.push({\r\n                reference: returnData.length,\r\n                contractAddress: token,\r\n                abi: erc20Abi,\r\n                calls: [\r\n                    { reference: 'nameCall', methodName: 'name' },\r\n                    { reference: 'decimalsCall', methodName: 'decimals' },\r\n                    { reference: 'symbolCall', methodName: 'symbol' }\r\n                ]\r\n            })\r\n            returnData.push({\r\n                amount: amount,\r\n                claimedAmount: claimedAmount,\r\n                lockTimestamp: lockTimestamp,\r\n                lastUpdated: lastUpdated,\r\n                lockHours: lockHours,\r\n                contract: contract,\r\n                token: {\r\n                    address: token\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    response = await multicall.call(contractCallContext);\r\n    for (const [key, value] of Object.entries(response.results)) {\r\n        let name = value.callsReturnContext[0].returnValues[0];\r\n        let symbol = value.callsReturnContext[2].returnValues[0];\r\n        let decimals = value.callsReturnContext[1].returnValues[0];\r\n        returnData[key].token.name = name;\r\n        returnData[key].token.symbol = symbol;\r\n        returnData[key].token.decimals = decimals;\r\n    }\r\n    return returnData;\r\n}\r\n\r\nexport const claimToken = async (provider, tokenDetail, account) => {\r\n    let currentTimestamp = Math.floor(Date.now() / 1000);\r\n    if (currentTimestamp - tokenDetail.lastUpdated < 3600) return {state: false, reason: 'Wait to next claim available'};\r\n    const passedHours = Math.floor((currentTimestamp - tokenDetail.lockTimestamp) / 3600);\r\n    let availableAmount = BigInt(Math.floor(tokenDetail.amount * passedHours / tokenDetail.lockHours) - tokenDetail.claimedAmount).toString();\r\n    if (Number(availableAmount) > maxTxLimit) availableAmount = maxTxLimit.toString();\r\n    const web3 = new Web3(provider);\r\n    const abi = [{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"}],\"name\":\"claimToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]\r\n    const contract = new web3.eth.Contract(abi, tokenDetail.contract);\r\n    const response = await contract.methods.claimToken(availableAmount).send({\r\n        from: account\r\n    });\r\n    console.log(response);\r\n}\r\n\r\nexport const airdrop = async (provider, csvData, token, account, network) => {\r\n    let _users = [], _amounts = [];\r\n    const web3 = new Web3(provider);\r\n    let abi = [{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}];\r\n    // console.log(token)\r\n    let contract = new web3.eth.Contract(abi, token);\r\n    let decimals = await contract.methods.decimals().call();\r\n    csvData.map(each => {\r\n        _users.push(web3.utils.toChecksumAddress(each.address));\r\n        _amounts.push(BigInt(each.amount * Math.pow(10, decimals)).toString());\r\n    })\r\n    // console.log(_users)\r\n    // console.log(_amounts)\r\n    abi = [{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint128[]\",\"name\":\"_amounts\",\"type\":\"uint128[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companyWallet\",\"outputs\":[{\"internalType\":\"addresspayable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesInETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]\r\n    contract = new web3.eth.Contract(abi, airdropAddress[network]);\r\n    let feeInETH = await contract.methods.feesInETH().call();\r\n    let result = await contract.methods.airdrop(token, _users, _amounts).send({\r\n        from: account,\r\n        value: network === \"Avalanche\" || network === \"Avalanche_testnet\" ? BigInt(feeInETH * Math.pow(10, 18)).toString() : feeInETH\r\n    });\r\n    return result;\r\n}"],"sourceRoot":""}